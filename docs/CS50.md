# [CS50 - 부스트코스](https://www.boostcourse.org/cs112/joinLectures/41307)

### 목차

- [1. 컴퓨팅 사고](#1-컴퓨팅-사고)
- [2. C](#2-c)
- [3. Array](#3-array)
- [4. 알고리즘](#4-알고리즘)
- [5. 메모리](#5-메모리)
- [6. 자료구조](#6-자료구조)

# 1. 컴퓨팅 사고

이진법의 한 자리를 bit라고 한다. bit는 0또는 1을 뜻한다. 8bit는 1byte이다. 

컴퓨터에서는 문자 역시 이진법으로 표현된다. ASCII로 A는 65이다. 

아스키는 8비트만 사용하기 때문에 다양한 문자를 표현하기에는 부족했다. 다양한 문자를 표현하기 위해서 8,16,24,32비트까지도 사용하는 유니코드를 사용한다.

이미지도 마찬가지로 이진수로 표현한다. 하나의 픽셀마다 빨강, 초록, 파랑을 적절히 조합하면 원하는 색을 얻을 수 있다. 각각의 색의 정도는 숫자로 표현한다.

같은 맥락으로 영상과 소리도 숫자로 표현할 수 있다.

## 알고리즘

알고리즘은 문제를 해결하는 단계적인 방법이다. 1000페이지 짜리 전화번호부에서 원하는 전화번호를 찾는 과정을 살펴본다. 

한 페이지씩 넘기면 1000번, 2페이지 씩 넘기면 500번을 넘겨야 된다. 하지만 이름 순으로 정렬되어 있다면 가장 먼저 반을 갈라서 앞 쪽을 볼 건지 뒷 쪽을 볼 건지 결정할 수 있다.

이 방법을 사용하면 10번이면 원하는 전화번호를 찾을 수 있다. 

문제의 크기와 문제를 해결하는 시간을 그래프로 나타내면 다음과 같다.

<img width="512" alt="image" src="https://user-images.githubusercontent.com/89520805/224451055-b1f38acb-48e8-43a0-9999-ccb813afedf3.png">

# 2. C

https://sandbox.cs50.io 에서 실습을 할 수 있다.
[여기](https://www.boostcourse.org/cs112/lecture/133454?isDesc=false)에서 사용방법을 확인할 수 있다.

```c
#include <stdio.h>

int main(void) {
    printf("hello, world!\n");
}
```
위에 있는 코드를 소스 코드라고 한다. 소스 코드는 사람이 이해할 수 있는 코드다. 
컴퓨터는 0과 1만 이해할 수 있기 때문에 소스 코드를 기계가 이해할 수 있는 기계어로 번역하는 과정이 필요하다.
이 과정을 "**컴파일**"이라고 한다. 컴파일을 하기 위해서는 터미널에 `clang hello.c(소스코드명)`을 입력하면 된다. 
컴파일을 하면 기계어 파일이 생성된다. `./a.out(기계어파일명)`을 입력하면 터미널에 `hello, world!`가 출력된다. 

이번에는 조금 더 나아가서 사용자의 이름을 입력받아 `hello, 이름`을 출력하는 프로그램을 작성해본다.

```c
#include <cs50.h>
#include <stdio.h>

int main(void) {
    string answer = get_string("What's your name?\n");
    printf("hello, %s\n", answer);
}
```
이대로 컴파일을 해보면 에러가 발생한다. `get_stirng()` 함수를 찾지 못했기 때문이다. 컴파일할 때 함수가 정의된 cs50 파일을 연결해줘야 한다.
`clang hello.c -lcs50`를 입력하면 에러없이 컴파일된다. 더 쉬운 방법이 있다. `make hello`라고 입력하면 알아서 파일도 연결하고 이름도 설정해준다.

- 함수

```c
#include <cs50.h>
#include <stdio.h>

string even_or_odd(void);

int main(void) {
    printf("%s", even_or_odd());
}

string even_or_odd(void) {
    return get_int("n: ") % 2 == 0 
            ? "even\n" 
            : "odd\n";
}
```

함수를 정의할 때는 main 함수보다 위에 정의해야 에러가 안 난다. 하지만 main 함수는 말 그대로 main 이기 때문에 파일 위쪽에 있는 것이 좋다.
이때 쓸 수 있는 방법으로 함수의 선언부만 위에 적어두고 아래에 구현부는 main 함수 밑에 적을 수 있다. 마치 인터페이스를 위에 정의하고 
다른 클래스에서 구현하는 것처럼 말이다. 

컴퓨터의 메모리는 물리적인 한계가 있기 때문에 데이터가 허용된 범위를 넘어서면 넘쳐버린다. 이를 Overflow 라고 한다.

# 3. Array

## 컴파일 과정

1. preprocessing
2. compiling
3. assembling
4. linking

4가지 과정을 거쳐서 소스 코드는 기계어로 번역된다. 

```c
#include <stdio.h>

int main(void) {
    printf("hello, world!\n");
}
```

위 소스 코드가 컴파일되는 과정을 살펴본다.  

1. preprocessing

preprocessing 단계에서는 `#include <stdio.h>`를 실제 소스 코드로 변환한다.

2. compiling
    
소스 코드를 어셈블리 코드로 변환한다. 

3. assembling
    
어셈블리 코드를 기계어로 변환한다. 

4. linking
   
변환된 기계어들을 하나의 파일로 합친다. 
`hello.c` 와 `stdio.h`를 각각 기게어로 변환 후 하나의 파일로 합치는 작업이다.

## 메모리

메모리는 바이트로 이루어져있다. (물론 비트로 한 번 더 쪼갤 수도 있다.) boolean은 1 바이트, char 도 1 바이트의 저장 공간을 차지한다. 
메모리의 1 바이트를 물리적으로 차지한다. 


### 상수

`const int N = 3;` 상수의 경우 이런 식으로 전역 변수로 선언할 수 있다.

C에서는 배열의 길이를 배열이 기억하고 있지 않다. 따라서 배열을 인자로 넘길 때 배열의 길이가 필요하면 배열의 길이 역시 함께 넘겨줘야 한다. 

## 문자열

문자열은 말 그대로 문자(char)의 배열이다. 여러 문자가 모여 문자열을 이룬다. 예를 들어 `string s = "hi!";`라는 문자열을 선언하면 메모리는 4바이트의 저장공간이 할당된다.
'h', 'i', '!', '\0' 이렇게 1 바이트 씩 생긴다. '\0'은 문자열의 끝을 알려주는 기호로 null을 뜻한다. 모든 문자열은 마지막을 뜻하는 '\0'으로 끝난다.  
'h'는 s[0], 'i'는 s[1], '!'는 s[2], '\0'은 s[3]으로 표현할 수 있다.

`printf()`에서 `%s`를 사용하면 내부적으로 문자를 하나씩 확인해서 null이 아니라면 출력하는 식으로 동작한다. 

문자열 배열의 경우는 문자열이 순서대로 메모리에 저장되어 있다. 

```c
string names[2];

names[0] = "EVE";
names[1] = "PARK";
```

'E', 'V', 'E', '\0', 'P', 'A', 'R', 'K' 이렇게 순서대로 저장되어 있다. names[0]은 'E'를 가르키고 names[1]은 'P'를 가르킨다.

### 대소문자 변환

아스키 코드를 살펴보면 'A'=65, 'a'=97, 'B'=66, 'b'=98 이다. 대문자와 소문자는 32 만큼 차이난다. 이걸 이용해서 대소문자를 판별할 수 있고 나아가서 대소문자 변환할 수 있다.
```c
for (int i = 0, n = strlen(s); i < n; i++) {
    char tmp = s[i];
    if  (tmp >= 'a' && tmp <= 'z')
        tmp -= 32;
}
```

# 4. 알고리즘

여러 데이터가 든 배열에서 원하는 데이터를 찾는 방법은 여러 가지가 있다. 데이터가 정렬되어 있지 않다면 최선의 방법은 처음부터 순차적으로 하나 씩 찾아보는 방법이다. 
이걸 '**선형탐색**'이라고 한다. 선형탐색은 최악의 경우 원하는 데이터가 배열의 마지막에 있을 수 있기 때문에 효율적인 알고리즘이라고 할 수는 없다. 

만약 데이터가 정렬되어 있다면 '**이진탐색**'을 할 수 있다. 배열의 중간부터 시작해서 왼쪽이나 오른쪽을 정해서 다시 중간을 살펴본다. 계속해서 대소관계를 비교하며 찾아나가기 때문에 
선형탐색에 비해서 매우 효율적으로 원하는 데이터를 찾을 수 있다. 가장 큰 제약조건으로 정렬이 되어 있어야 한다.

## 알고리즘 표기법 : Big-O

<img width="512" alt="image" src="https://user-images.githubusercontent.com/89520805/224451055-b1f38acb-48e8-43a0-9999-ccb813afedf3.png">

전화번호부를 한 장씩 넘기는 알고리즘(선형탐색)의 경우 O(N)으로 표기할 수 있다. 2장 씩 넘기는 경우는 O(n/2)이다. 하지만 두 방법 모두 O(n)으로 표기한다. 
왜냐면 문제가 매우 크다고 가정하고 그래프를 그려보면 결국 거의 같은 선으로 표현되기 때문이다. 
Big-O 표기법은 알고리즘의 추세가 중요하지 실제 수행속도를 정확히 측정하는 것은 중요하지 않다. 

이진 탐색의 경우 O(log n)으로 선형탐색에 비해 빠르다.

O는 알고리즘의 상한선, 즉 최악의 상황을 뜻한다. 반대로 Ω 는 알고리즘의 하한선, 즉 최선의 상황이다.
선형탐색의 경우 최악의 경우 총 데이터의 수인 n 만큼 탐색해야 하기 때문에 O(n)이고 운이 좋은 경우 단 한 번으로 원하는 값을 찾을 수 있기 때문에 Ω(1)이다.

알고리즘을 두 가지 측면에서 파악할 수 있다.

- Ω : 하한선 (최상의 경우)

| 표기법        | 알고리즘       |
|------------|------------|
| $Ω(n^2)$     ||
| $Ω(n log n)$ ||
| $Ω(n)$       ||
| $Ω(log n)$   ||
| $Ω(1)$       | 선형탐색, 이진탐색 |

- O : 상한선 (최악의 경우)

| 표기법        | 알고리즘 |
|------------|------|
| $O(n^2)$     ||
| $O(n log n)$ ||
| $O(n)$       | 선형탐색 |
| $O(log n)$   | 이진탐색 |
| $O(1)$       ||

배열의 수를 세는 알고리즘의 경우 Ω(n), O(n)이다. 최상의 경우에도, 최악의 경우에도 원소를 모두 세야하기 때문이다.   

## 구조체

전화번호부를 만들 때 배열 2개를 사용해서 이름과 전화번호를 각각 저장한다. 

```c
string names[4] = {"SANDRO", "SUMMER", "MIKA", "SORI"};
string numbers[4] = {"010-1234-4323", "010-4232-4323", "010-4141-4323", "010-9375-4323"};
```

이렇게 하면 한 쪽 배열의 순서가 바뀌면 이름과 전화번호를 매칭할 수 없다. 다른 방법이 필요하다.
**구조체**를 사용한다. 

```c
typedef struct
{
    string name;
    string number;
}
person;

person people[4];
people[0].name = "SANDRO";
people[0].number = "010-3324-1415";
people[1].name = "SUMMER";
people[1].number = "010-1423-5432";
people[2].name = "MIKA";
people[2].number = "010-3411-6372";
people[3].name = "SORI";
people[3].number = "010-2234-5566";
```
 
person 구조체를 정의하고 person 배열을 만든다. person은 name, number로 이루어져 있다. 
이제 두 데이터는 묶여있기 때문에 이름이나 전화번호로 정렬할 수 있다.

## 정렬

### 버블 정렬
  
버블정렬은 배열을 순회하면서 두 숫자를 비교해서 순서가 잘못되었으면 자리를 바꾸는 식으로 정렬한다. 한 번 순회하는 걸로는 정렬이 되지 않기 때문에 정렬이 될 때까지 배열을 순회해야 한다. $O(n^2)$이다. 

이렇듯 정렬하는데도 시간이 들기 때문에 선형탐색과 이진탐색 중 단순히 뭐가 좋다라고 할 수는 없다. 상황에 따라 다르다. 물론 10번 조회해야 한다면 10번 선형탐색하는 것 보다 1번 정렬해놓고 10번 이진탐색하는 것이 훨씬 효율적일 것이다. 

버블 정렬은 정렬되어 있는 배열에도 $n^2$ 번을 선회하기 때문에 최상의 경우에도 $Ω(n^2)$ 이다. 
(한 번 순회하고 정렬되어 있으면 멈추는 로직을 추가하면 $Ω(n)$ 으로 만들 수 있을듯.)

| 표기법        | 알고리즘       |
|------------|------------|
| $Ω(n^2)$     |버블정렬|
| $Ω(n log n)$ ||
| $Ω(n)$       ||
| $Ω(log n)$   ||
| $Ω(1)$       | 선형탐색, 이진탐색 |

| 표기법        | 알고리즘 |
|------------|------|
| $O(n^2)$     |버블정렬|
| $O(n log n)$ ||
| $O(n)$       | 선형탐색 |
| $O(log n)$   | 이진탐색 |
| $O(1)$       ||

### 선택 정렬

선택 정렬을 배열을 순회하면서 가장 작은 값을 찾고 그 값을 배열의 앞으로 보낸다. 정렬될 때까지 반복한다. 
선택 정렬 역시 버블정렬과 마찬가지로 $O(n^2)$이다. 최상의 경우도 모두 다 확인해봐야 하기 때문에 $Ω(n^2)$ 이다. 

| 표기법        | 알고리즘       |
|------------|------------|
| $Ω(n^2)$     |선택정렬|
| $Ω(n log n)$ ||
| $Ω(n)$       |버블정렬|
| $Ω(log n)$   ||
| $Ω(1)$       | 선형탐색, 이진탐색 |

| 표기법        | 알고리즘 |
|------------|------|
| $O(n^2)$     |버블정렬, 선택정렬|
| $O(n log n)$ ||
| $O(n)$       | 선형탐색 |
| $O(log n)$   | 이진탐색 |
| $O(1)$       ||

버블 정렬의 하한선을 조금 더 향상 시킬 수 있다. 지금은 이미 정렬된 배열이 주어져도 $n^2$을 순회하지만 조건문을 추가해서 해당 조건을 만족하면 작업을 멈춘다면 최선의 경우 $O(n)$으로 만들 수 있다.

## 재귀

재귀는 함수가 내부에서 자기 자신을 호출하는 것이다. 자기 자신을 계속 호출하기 때문에 while 문과 마찬가지로 조건을 정해주지 않으면 무한 반복하게 된다. 
보통 내부에 반복을 끝내는 조건문을 만들어두고 인자를 증가시키거나 감소시키면서 다시 호출한다. 

### 병합 정렬

병합 정렬은 버블 정렬과 선택 정렬보다 성능이 나은 정렬 알고리즘이다. 

`[4,3,2,1]`을 정렬 해본다. 

1. 배열을 반으로 나눈다. [4, 3], [2, 1]
2. 왼쪽을 다시 반으로 나눈다. [4], [3]
3. 원소가 한 개이기 때문에 둘을 병합한다. 병합할 때는 두 수 중 작은 수를 앞에 둔다. [3, 4]
4. 남은 오른쪽도 정렬하기 위해 반으로 나눈다. [2], [1]
5. 병합한다. [1, 2]
6. 양쪽 모두 정렬이 되었기 때문에 병합한다. [1, 2, 3, 4]

시간복잡도는 $O(n log n)$ 이다. 배열을 원소 1개로 나누는 과정이 log n 번 수행되고 쪼개진 원소(n)를 순회해야 하기 때문이다. 
최선의 경우 역시 $Ω(n log n)$ 이다. 

| 표기법        | 알고리즘       |
|------------|------------|
| $Ω(n^2)$     |선택정렬|
| $Ω(n log n)$ |병합정렬|
| $Ω(n)$       |버블정렬|
| $Ω(log n)$   ||
| $Ω(1)$       | 선형탐색, 이진탐색 |

| 표기법        | 알고리즘 |
|------------|------|
| $O(n^2)$     |버블정렬, 선택정렬|
| $O(n log n)$ |병합정렬|
| $O(n)$       | 선형탐색 |
| $O(log n)$   | 이진탐색 |
| $O(1)$       ||

최악의 경우로 비교하면 지금까지 살펴본 정렬 알고리즘 중 가장 성능이 좋다. 최선의 경우 버블 정렬보다는 성능이 떨어진다. 

## Θ

알고리즘의 상한선과 하한선이 같은 경우 Θ로 표현할 수 있다. 

| 표기법        | 알고리즘 |
|------------|------|
| $Θ(n^2)$     |선택정렬|
| $Θ(n log n)$ |병합정렬|
| $Θ(n)$       ||
| $Θ(log n)$   ||
| $Θ(1)$       ||

# 5. 메모리

## 16진수

컴퓨터는 16진수를 사용하는 경우가 있다. `1,2,3,4,5,6,7,8,9,A,B,C,D,E,F` 이렇게 표현한다. A=10, F=15다.

1 바이트의 최대 숫자는 255다. 이걸 16진수로 표현하면 FF다. 16진수는 색을 표현할 때 유용하다. RGB 각 색은 0부터 255로 표현할 수 있다. 검정은 RGB 모두 0이다. 검정을 16진수로 표현하면 000000이다. 빨강은 R=255,G=0,B=0이다. 이걸 16진수로 표현하면 FF0000이다. 따라서 하얀색은 FFFFFF로 표현할 수 있다. 

16진수는 16진수라는 것을 명확하게 표현하기 위해 0x를 앞에 붙인다. 0x0 ~ 0xF, 0x10 ~ 0x1F, 0x20 ~ 0x2F 이런 식이다. 

## 변수와 메모리

`int n = 50;`이란 코드를 메모리에서 살펴본다. int형 변수를 선언하면 메모리의 어딘가에 4byte 만큼의 공간에 50이라는 값을 저장한다. c에서는 다음과 같은 문법으로 변수의 메모리 주소를 확인할 수 있다.

```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%p\n", &n);
}

>>> 0x16cf6aecc
```

`*`를 사용하면 해당 변수의 실제 값을 얻을 수 있다. '&'로 변수의 메모리 주소를 얻어낸 다음 `*`로 해당 주소의 값을 얻어온다. 

```c
printf("%i\n", *&n);

>>> 50
```

## 포인터

지금까지는 변수를 선언할 때 값으로 정수나 문자 등을 지정했다. `int n = 50;` 처럼 말이다. 변수를 선언할 때 값으로 **다른 변수의 주소**를 지정할 수 있다. 이런 변수를 **포인터**라고 한다. 변수의 메모리 주소를 가진 변수를 뜻한다. 포인터의 자료형은 해당 주소에 들어있는 자료형으로 선언하면 된다.

```c
int n = 50;

int *p = &n;
printf("%p\n", p);  // 주소를 출력
printf("%i\n", *p); // 값을 출력

>>> 0x16cf6aecc
>>> 50
```

## 문자열

`string s = "EMMA";`를 좀 더 자세히 알아본다. "EMMA"는 메모리상에 일렬로 'E', 'M', 'M', 'A', '\0'로 저장되어 있다. 변수 s는 문자열의 시작인 'E'의 메모리 주소를 값으로 가진 포인터다. 문자는 메모리상에 일렬로 자리하기 때문에 문자열의 시작 위치만 알면 종단문자('\0')가 나올 때까지 순서대로 조회할 수 있다. 따라서 문자열은 `char *s = "EMMA";`로 표현할 수 있다.

이제 우리가 직접 문자열 자료구조를 선언할 수 있다. 

```c
typedef char *string;
```

문자를 값으로 갖는 주소를 저장하는 자료구조이다. 

```c
string s = "EMMA";

printf("%p\n", s);
printf("%p\n", &s[0]);  // 첫번째 문자의 주소

>>> 0x102c07fa8
>>> 0x102c07fa8
```

s의 주소와 s의 가장 처음 문자의 주소를 출력해보면 같은 값이다. 

```c
printf("%p\n", &s[0]);
printf("%p\n", &s[1]);
printf("%p\n", &s[2]);
printf("%p\n", &s[3]);

>>> 0x104063fa8
>>> 0x104063fa9
>>> 0x104063faa
>>> 0x104063fab
```

순대로 주소를 찍어보면 정말로 메모리 주소가 순서대로 되어있는 것을 확인할 수 있다.

이번에는 *s로 s의 주소가 가진 값을 접근해본다. 

```c
printf("%c\n", *s);

>>> E
```

첫번째 문자가 출력된다. 

두번째 문자를 접근할 때는 아래처럼 할 수 있다.

```c
printf("%c\n", *(s+1));

>>> M
```

s는 주소이기 때문에 + 1을 하면 다음 문자의 주소가 된다. 그리고 *로 해당 주소의 값에 접근할 수 있다. 
`s[0], s[1]` 이렇게 적으면 컴파일 시 `*s, *(s+1)` 이런 식으로 변환된다.

`printf("%s", s)`로 "EMMA"가 한 번에 출력되는 이유는 printf와 %s 때문이다. '\0'이 나올 때까지 문자를 하나씩 출력해준다.

### 문자열 비교

```c
int i = 1;
int j = 1;

i == j;  // true
```

숫자의 경우 위처럼 비교하면 두 변수는 같다고 나온다. 숫자는 해당 변수에 1이 바로 저장되어 있기 때문이다.

```c
string s = "Emma";
string t = "Emma";

s == t;
```

이 경우에는 어떨까? 답은 `false`다. 문자열의 경우 문자 배열이 메모리의 다른 공간에 저장되고 변수 s와 t는 각 문자 배열의 시작 주소를 값으로 가지고 있다. 따라서 `s == t`는 두 주소를 비교하기 때문에 다르다.

### 문자열 복사

```c
char *s = "emmma";
char *t = s;
```

문자열을 복사할 때는 위처럼 하면 안된다. 이렇게 하면 s, t 모두 같은 메모리 주소를 갖게된다. 

제대로 복사하기 위해서는 t에 새로운 메모리를 할당하고 s의 값을 옮겨야 한다.

```c
char *s = "emmma";
char *t = malloc(strlen(s) + 1);
```

`malloc()`을 사용해서 메모리를 할당할 수 있다. s + 1 만큼 메모리를 할당한다. +1 하는 이유는 '\0'(종단문자)를 추가하기 위해서다.

그리고 반복문을 돌면서 s의 값을 t에 할당한다.

```c
for (int i = 0, n = strlen(s) + 1; i < n; i++)
    t[i] = s[i];
```

이렇게 복사할 수 있다. 직접 반복문을 사용하지 않고 `<sting.h>`에 있는 `strcpy()` 메서드를 사용하면 편하다. 

## 메모리 해제

`malloc()`으로 메모리를 할당했다면 그 변수가 더 이상 필요없어지면 메모리를 해제해야 한다. C는 GC가 없기 때문에 직접 해제해줘야 한다. 누적된다면 메모리 누수로 프로그램이 죽는다. 메모리를 해제할 때는 `free(변수)`를 사용한다. 

### 주의사항

```c
int *i = malloc(sizeof(int));   // 4
i[1] = 0;
```

`malloc()`으로 int 만큼의 공간, 즉 4바이트를 변수 i에 할당했다. i[1]은 내가 할당한 메모리가 아니다. 나는 4바이트만 할당했기 때문에 i는 정수 1개만 넣을 수 있다. 하지만 C는 i[1], 즉 i + 1로 내가 할당한 메모리를 넘어서는 메모리에 접근할 수 있다. 

i[1]에 0을 할당하고 i를 해제해도 i[1]은 해제되지 않는다. **메모리 누수**가 생긴다. 조심해야 한다.

## 메모리 구조

메모리는 위에서부터 구역을 나눠서 사용한다. 
1. 컴파일러가 생성한 기계어
2. 전역 변수
3. 힙 - `malloc()`으로 메모리를 할당할 때 힙 영역을 사용한다. 힙은 위에서부터 아래로 사용된다. 자바에서 인스턴스가 위치하는 곳과 같다. 
4. 스택 - 스택은 아래부터 위로 사용된다. 함수가 호출될 때마다 아래부터 쌓이게 된다. `main()` 함수가 실행되면 가장 아래 **프레임**이 생성되고 프레임 안에 함수의 지역변수가 생성된다. 함수 호출이 끝나면 프레임은 사라지기 때문에 기본적으로 변수는 직접 해제하지 않아도 된다. 하지만 힙에서 할당 받은 메모리의 경우 프레임이 사라져도 해제하지 않으면 남아있는다. 왜냐하면 스택에 있는 변수는 힙 메모리의 포인터기 때문이다. 단순히 힙 메모리의 주소를 가지고 있기 때문에 프레임이 사라지면서 포인터가 사라진다 해도 힙 메모리의 할당된 영역은 영향을 받지 않는다. 그저 포인터가 사라져서 다시 접근할 수 없게 된다. 

### 오버플로우

`malloc()`을 너무 많이 해서 메모리가 부족해지는 현상을 '힙 오버플로우'라고 한다. 비슷하게 함수를 너무 많이 호출해서 스택이 넘치는 현상을 '스택 오버플로우'라고 한다. 이런 현상을 '버퍼 오버플로우'라고 한다.

# 6. 자료구조

```c
int *x;
int *y;

x = malloc(sizeof(int));

*x = 42;
*y = 13;
```

이 코드에는 버그가 있다. `*y = 13;` 이다. x에는 메모리를 할당했지만 y는 아직 메모리를 할당하지 않았다. 이때 `*`을 사용해서 주소로 가려고 하면 
할당된 메모리가 없기 때문에 에러가 난다.

`malloc()`은 메모리가 부족한 경우 제대로 할당되지 않을 수 있다. 따라서 메모리를 할당한다음 제대로 할당되었는지 확인하기 위해서는 `null`체크를 하면 된다.  

## 배열

크기가 3인 배열 꽉차서 배열의 크기를 늘려야할 때는 더 큰 배열을 생성해서 값을 복사해야 한다. 배열의 원소의 수에 따라 복사하는데 시간이 걸리기 때문에 `O(n)`이다. 

- 복사하는 방법

```c
int *list = malloc(3 * sizeof(int));    // 메모리 할당
if (list == NULL) return 1;             // null 체크

for (int i = 0; i < 3; i++)             // 값 설정
    list[i] = i + 1;

int *tmp = malloc(4 * sizeof(int));     // 더 큰 배열 생성
if (tmp == NULL) return 1;

for (int i = 0; i < 3; i++)             // 값 복사
    tmp[i] = list[i];
tmp[3] = 4;

free(list);                             // 기존 배열 할당해제

list = tmp;                        
```

이 과정을 `realloc()`을 사용해서 조금 더 간단하게 바꿀 수 있다.

```c
int *list = malloc(3 * sizeof(int));    // 메모리 할당
if (list == NULL) return 1;             // null 체크

for (int i = 0; i < 3; i++)             // 값 설정
    list[i] = i + 1;

int *tmp = realloc(list, 4 * sizeof(int));     // 더 큰 배열 생성
if (tmp == NULL) return 1;
tmp[3] = 4;
````

`realloc()`은 값 복사와 기존 메모리 할당해제를 대신해주기 때문에 코드가 줄었다.

## Linked List

위에서 살펴본대로 배열은 처음에 정의한 크기를 늘리기 위해서는 새로운 배열을 생성하고 원래 값을 복사해야 한다. 또 배열은 메모리상에 데이터가 일렬로 존재하기 때문에 중간에 새로운 값을 추가하기 위해서는 새로운 값이 들어갈 공간을 마련해야 한다. 공간을 마련하는 방법은 데이터를 한 칸 씩 뒤로 미는 것이다. 이것도 데이터가 많을 수록 시간이 많이 걸릴 것이다. 정리하자면 배열의 크기를 늘리는 작업과 새로운 값을 추가하는 작업은 모두 `O(n)`으로 느린 편이다. 

반면 연결리스트는 길이를 늘리거나 중간에 값을 추가하는 작업이 매우 빠르다. 연결리스트는 구조체를 사용해서 구현한다. 

```c
typedef struct node
{
    int number;
    struct node *next;
}
node;
```
node라는 구조체는 2가지 데이터를 가지고 있다. 노드의 값과 다음 노드의 포인터다. 연결리스트는 노드의 연결로 이루어져있다. 하나의 노드는 다음 노드의 포인터를 가지고 있기 때문에 순서대로 리스트를 순회할 수 있다. 연속적인 자료구조다. 물리적으로는 배열과 다르게 메모리상에서는 연속적이지 않다. 포인터로 연결되어 있기 때문에 연속적으로 느껴진다. 

### 구현

```c
node *list = NULL;
```

먼저 포인터를 선언한다. `NULL`로 초기화해서 아무것도 가르키지 않는다. 

```c
node *n = malloc(sizeof(node));
if (n != NULL) return 1;
n->number = 2;
n->next = NULL;

list = n;
```

임시로 노드를 생성해서 node 만큼 메모리를 할당받는다. 값을 지정하고 next는 없기 때문에 NULL로 초기화한다. 이제 list에 n을 할당하면 두 포인터는 한 곳을 가르키게 된다. 

```c
printf("%i\n", list->number);

>>> 2
```

`2`가 출력되는 것을 확인할 수 있다. list는 포인터기 때문에 필드에 접근하기 위해서는 `(*list).number` 이렇게 해야 한다. 이걸 간단하게 `list->number`로 표현할 수 있다.

한 번 더해본다. 2뒤에 3을 추가한다.

```c
n = malloc(sizeof(node));
if (n != NULL) return 1;
n->number = 3;
n->next = NULL;

list->next = n;

printf("%i\n", list->next->number);

>>> 3
```

다시 node만큼 메모리를 할당받아 값을 설정한다. 그리고 list의 next로 생성한 node를 지정한다. 2와 3이 순서대로 list에 저장되게 된다.

이번에는 list 맨 앞에 1을 추가해본다. 

```c
node *n = malloc(sizeof(node));
if (n == NULL) return 1;
n->number = 1;

n->next = list;     // 1 -> 2
list = n;           // 리스트의 시작이 1로 바뀐다.
```

중요한 부분은 생성한 n의 next를 list로 지정한 것이다. list는 2를 가르키고 있고 n은 1이기 때문에 1이 2를 가르키게 만든다. 그리고 list가 n을 가르키게 만들면 이제 리스트는 1,2,3이 된다.

## 배열과 연결리스트

연결리스트는 랜덤엑세스할 수 없기 때문에 이진탐색을 할 수 없다. 따라서 원하는 요소를 조회하기 위해서는 순서대로 요소를 탐색해야 한다.

| 표기법        | 알고리즘 |
|------------|------|
| $O(n^2)$     ||
| $O(n log n)$ ||
| $O(n)$       |배열(요소추가), 연결리스트(선형탐색)|
| $O(log n)$   |배열(이진탐색)|
| $O(1)$       ||

## 트리

연결리스트에서 사용한 노드를 조금 수정하면 **트리**를 구현할 수 있다. 트리는 가계도처럼 노드가 계층 구조로 이루어진 자료구조이다.
**이진 탐색 트리**는 말 그대로 이진 탐색을 할 수 있는 트리다. 이진 탐색 트리에서 노드는 숫자와 2개의 포인터를 가지고 있다. 하나는 자신보다 작은 숫자를 가르키고 하나는 자신보다 큰 숫자를 가르킨다.

## 해시테이블

해시테이블은 이론적으로는 어떤 대상을 `O(1)`, 즉 상수시간만에 검색할 수 있다. 해시테이블은 배열과 연결리스트를 조합해서 만들 수 있다. 

큰 행사에서 참석자에게 이름표를 줘야하는 상황을 가정해본다. 성에 따라 이름표를 상자에 넣어 구분해두고 각자 이름표를 챙겨가게 할 수 있다. 특이한 성을 가진 사람이 한 명 밖에 없다면 그 사람은 해당 성을 찾기만 하면 바로 자신의 이름표를 찾을 수 있다. 하지만 '김'씨의 경우 같은 성을 가진 사람이 많기 때문에 성을 찾아도 상자 안에서 자신의 이름을 찾아야 한다. 이 상자가 배열이고 상자안의 이름표는 연결리스트로 연결되어 있다고 볼 수 있다. '김'씨의 경우 같은 성을 가진 사람이 많기 때문에 이름을 찾기 위해 걸리는 시간을 `O(n)`이라고 할 수 있다. 만약 모든 이름이 다 다른 상자에 들어있다면 `O(1)`이다. 

## 트라이

트라이는 검색과 요소 추가 모두 `O(1)`이다. 대신 메모리를 많이 사용한다. 

