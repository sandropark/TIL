# CS50

# 1. 컴퓨팅 사고

이진법의 한 자리를 bit라고 한다. bit는 0또는 1을 뜻한다. 8bit는 1byte이다. 

컴퓨터에서는 문자 역시 이진법으로 표현된다. ASCII로 A는 65이다. 

아스키는 8비트만 사용하기 때문에 다양한 문자를 표현하기에는 부족했다. 다양한 문자를 표현하기 위해서 8,16,24,32비트까지도 사용하는 유니코드를 사용한다.

이미지도 마찬가지로 이진수로 표현한다. 하나의 픽셀마다 빨강, 초록, 파랑을 적절히 조합하면 원하는 색을 얻을 수 있다. 각각의 색의 정도는 숫자로 표현한다.

같은 맥락으로 영상과 소리도 숫자로 표현할 수 있다.

## 알고리즘

알고리즘은 문제를 해결하는 단계적인 방법이다. 1000페이지 짜리 전화번호부에서 원하는 전화번호를 찾는 과정을 살펴본다. 

한 페이지씩 넘기면 1000번, 2페이지 씩 넘기면 500번을 넘겨야 된다. 하지만 이름 순으로 정렬되어 있다면 가장 먼저 반을 갈라서 앞 쪽을 볼 건지 뒷 쪽을 볼 건지 결정할 수 있다.

이 방법을 사용하면 10번이면 원하는 전화번호를 찾을 수 있다. 

문제의 크기와 문제를 해결하는 시간을 그래프로 나타내면 다음과 같다.

<img width="512" alt="image" src="https://user-images.githubusercontent.com/89520805/224451055-b1f38acb-48e8-43a0-9999-ccb813afedf3.png">

# 2. C

https://sandbox.cs50.io 에서 실습을 할 수 있다.
[여기](https://www.boostcourse.org/cs112/lecture/133454?isDesc=false)에서 사용방법을 확인할 수 있다.

```
#include <stdio.h>

int main(void) {
    printf("hello, world!\n");
}
```
위에 있는 코드를 소스 코드라고 한다. 소스 코드는 사람이 이해할 수 있는 코드다. 
컴퓨터는 0과 1만 이해할 수 있기 때문에 소스 코드를 기계가 이해할 수 있는 기계어로 번역하는 과정이 필요하다.
이 과정을 "**컴파일**"이라고 한다. 컴파일을 하기 위해서는 터미널에 `clang hello.c(소스코드명)`을 입력하면 된다. 
컴파일을 하면 기계어 파일이 생성된다. `./a.out(기계어파일명)`을 입력하면 터미널에 `hello, world!`가 출력된다. 

이번에는 조금 더 나아가서 사용자의 이름을 입력받아 `hello, 이름`을 출력하는 프로그램을 작성해본다.

```
#include <cs50.h>
#include <stdio.h>

int main(void) {
    string answer = get_string("What's your name?\n");
    printf("hello, %s\n", answer);
}
```
이대로 컴파일을 해보면 에러가 발생한다. `get_stirng()` 함수를 찾지 못했기 때문이다. 컴파일할 때 함수가 정의된 cs50 파일을 연결해줘야 한다.
`clang hello.c -lcs50`를 입력하면 에러없이 컴파일된다. 더 쉬운 방법이 있다. `make hello`라고 입력하면 알아서 파일도 연결하고 이름도 설정해준다.

- 함수

```
#include <cs50.h>
#include <stdio.h>

string even_or_odd(void);

int main(void) {
    printf("%s", even_or_odd());
}

string even_or_odd(void) {
    return get_int("n: ") % 2 == 0 
            ? "even\n" 
            : "odd\n";
}
```

함수를 정의할 때는 main 함수보다 위에 정의해야 에러가 안 난다. 하지만 main 함수는 말 그대로 main 이기 때문에 파일 위쪽에 있는 것이 좋다.
이때 쓸 수 있는 방법으로 함수의 선언부만 위에 적어두고 아래에 구현부는 main 함수 밑에 적을 수 있다. 마치 인터페이스를 위에 정의하고 
다른 클래스에서 구현하는 것처럼 말이다. 

컴퓨터의 메모리는 물리적인 한계가 있기 때문에 데이터가 허용된 범위를 넘어서면 넘쳐버린다. 이를 Overflow 라고 한다.

# 3. Array

## 컴파일 과정

1. preprocessing
2. compiling
3. assembling
4. linking

4가지 과정을 거쳐서 소스 코드는 기계어로 번역된다. 

```
#include <stdio.h>

int main(void) {
    printf("hello, world!\n");
}
```

위 소스 코드가 컴파일되는 과정을 살펴본다.  

1. preprocessing

preprocessing 단계에서는 `#include <stdio.h>`를 실제 소스 코드로 변환한다.

2. compiling
    
소스 코드를 어셈블리 코드로 변환한다. 

3. assembling
    
어셈블리 코드를 기계어로 변환한다. 

4. linking
   
변환된 기계어들을 하나의 파일로 합친다. 
`hello.c` 와 `stdio.h`를 각각 기게어로 변환 후 하나의 파일로 합치는 작업이다.

## 메모리

메모리는 바이트로 이루어져있다. (물론 비트로 한 번 더 쪼갤 수도 있다.) boolean은 1 바이트, char 도 1 바이트의 저장 공간을 차지한다. 
메모리의 1 바이트를 물리적으로 차지한다. 


### 상수

`const int N = 3;` 상수의 경우 이런 식으로 전역 변수로 선언할 수 있다.

C에서는 배열의 길이를 배열이 기억하고 있지 않다. 따라서 배열을 인자로 넘길 때 배열의 길이가 필요하면 배열의 길이 역시 함께 넘겨줘야 한다. 

## 문자열

문자열은 말 그대로 문자(char)의 배열이다. 여러 문자가 모여 문자열을 이룬다. 예를 들어 `string s = "hi!";`라는 문자열을 선언하면 메모리는 4바이트의 저장공간이 할당된다.
'h', 'i', '!', '\0' 이렇게 1 바이트 씩 생긴다. '\0'은 문자열의 끝을 알려주는 기호로 null을 뜻한다. 모든 문자열은 마지막을 뜻하는 '\0'으로 끝난다.  
'h'는 s[0], 'i'는 s[1], '!'는 s[2], '\0'은 s[3]으로 표현할 수 있다.

`printf()`에서 `%s`를 사용하면 내부적으로 문자를 하나씩 확인해서 null이 아니라면 출력하는 식으로 동작한다. 

문자열 배열의 경우는 문자열이 순서대로 메모리에 저장되어 있다. 

```
string names[2];

names[0] = "EVE";
names[1] = "PARK";
```

'E', 'V', 'E', '\0', 'P', 'A', 'R', 'K' 이렇게 순서대로 저장되어 있다. names[0]은 'E'를 가르키고 names[1]은 'P'를 가르킨다.


