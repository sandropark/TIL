# C

- 컴파일 과정

우리가 작성하는 `~~.c`는 **소스코드**다. 인간을 위한 코드다. 이 코드를 CPU가 이해하는 기계어로 변환하는 작업인 **컴파일**은 컴파일러가 한다. `.c -> .obj -> .exe` 순으로 변환된다. .c는 설계도, .obj는 부품, .exe는 완성품이다. 설계도를 가지고 부품을 만드는 일은 컴파일러가 하고 부품을 가지고 완성품으로 조립은 **링커**가 한다.

## 자료형 Type

자료형은 **일정 길이**의 메모리에 저장된 정보의 **해석 방법**이다.

> 32bit?
>
> 32bit를 10진수로 표현하면 약 42.9억이다. GB로 환산하면 4GB이다. 그래서 32bit의 운영체제에서는 메모리를 최대 4GB까지 통제할 수 있다. 
>
> IP 주소도 32bit이다. `8bit.8bit.8bit.8bit`로 이루어져있다. 

4bit는 $2^4=16$이다. 0~15까지 16가지의 경우의 수가 있다.

메모리는 사물함이라고 생각하면 된다. 순서대로 각자의 **공간**과 **번호**를 가지고 있다. 각 공간의 크기는 1Byte이고 숫자는 **메모리의 주소**로 각 공간의 위치 정보를 나타낸다. 1Byte 한 공간은 "A"와 같은 영문 문자 하나를 표현할 수 있다. 

### 상수와 변수

- 변수 : 프로그램을 작성하는 입장에서 **아직 확정되지 않은 수**
- 상수 : 확정된 수

변수의 본질은 **메모리**다. 변수는 메모리를 가르키고 있다. 혹은 메모리의 주소를 가지고 있다고 할 수 있다. 메모리에 저장된 값은 **데이터**다.

컴퓨터는 숫자밖에 다룰 수 없기 때문에 문자 역시 숫자로 표현한다. 예를 들어 `65=a, 66=b`같이 말이다. 이런 규칙을 **부호체계**라고 한다.
컴퓨터가 처음 만들어질 당시, 미국에서는 표준 부호체계로 **ASCII**를 사용했다. 알파벳이나 특수문자 한 개를 8bit로 표현한다. 그래서 메모리의 최소 단위가 8bit이다.

- **자료**
  - 정수
    - 부호가 있는 정수 signed
      - 8bit 길이의 부호가 있는 정수를 문자 **char**이라고 한다. 이 숫자를 어떤 문자로 해석하기로 약속했기 때문이다.
    - 부호가 없는 정수 unsigned
  - 실수

### 정수형

8bit(Byte)로 예를들어 살펴본다. 맨 처음 bit는 부호(+/-)를 나타낸다. 0인 경우 +, 1인 경우 -이다. 그리고 나머지 7자리로 숫자를 표현한다. 숫자의 범위는 $2^7$ ~ $2^7-1$이다. 10진수로 표현하면 `-128 ~ 127`까지다. 

정수형 int의 경우 32bit의 저장공간을 사용한다. 맨 앞 비트는 부호를 나타내기 위해서 사용하기 때문에 총 31bit를 사용해서 $-2^{31}$ 부터 $2^{31}-1$로 약 -21억 ~ 21억 까지 나타낼 수 있다.

### 보수

1100 - 11을 계산해본다. 1100을 10진수로 나타내면 8+4로 2다. 11은 2+1로 3이다. 따라서 결과는 십진수로 9이다. 

1100 - 11은 1100 + (-11)라고 할 수 있고 조금 더 자세히 보면 1100 + 1011이라고 할 수 있다. (맨 앞자리는 부호를 나타내니까) 하지만 계산을 할 때는 음수를 이렇게 표현하지 않고 **보수**로 표현한다.

빼는 수 11의 보수를 구해서 1100과 더하면 된다. 보수를 구할 때는 1의 보수나 2의 보수를 구할 수 있다. 결과는 동일하다. 먼저 1의 보수를 이용해본다.

11의 1의 보수를 구하는 방법은 다음과 같다.
1. 먼저 두 수의 길이를 같게 만든다. 11을 1100과 같게 만들기 위해서 `0011`로 표기한다.
2. 0은 1로, 1은 0으로 바꿔준다. `0011 -> 1100`
3. 이제 1100과 더한다. `1100 + 1100 = 11000`
4. 4bit 두 수를 더해서 5bit 숫자가 나왔다. 1의 보수에서는 자리올림된 경우 앞의 자리를 없애고 +1을 해주면 된다. `11000 -> 1001`
5. 결과는 `1001`으로 9이다.

이번에는 2의 보수를 이용한다. 거의 비슷하다. 2의 보수를 구하는 법은 1의 보수를 구한 다음 +1하면 된다. `0011 -> 1101` 이제 두 수를 더하고 자리올림된 수는 그냥 버리면 된다.
`1100 + 1101 = 1001` 결과는 역시 동일하게 9이다.

> *주의
>
> 보수를 취한 다음 덧샘을 했는데 자리올림(캐리)가 발생하지 않은 경우 다시 보수를 취해줘야 한다.
> 
> 10-13을 예시로 살펴본다. 
> 
> 1. 먼저 두 수를 2진수로 표현한다. `10 = 1010, -13 = -1101`이다. 
> 2. -13의 보수를 취한다. 2의 보수를 사용한다. `-1101 -> 0011`
> 3. 두 수를 더한다. `1010 + 0011 = 1101` 
> 4. 캐리가 발생하지 않았기 때문에 결과의 보수를 취한다. (2의 보수로) `1101 -> -0011`
> 5. 결과는 `-0011 = -3`이다.  

### signed? unsigned?

4bit `-1 = -0001`의 2의 보수는 1111이다. 1111이란 숫자는 15로 해석될 수도 있고 -1로 해석될 수도 있다. -1은 부호가 있는 경우이고 15는 부호가 없는 경우다. 

보통 정수형 변수를 선언할 때 `int a;`라고 표현한다. 엄밀히 말하면 `signed int a;`에서 signed가 생략된 것이다. 조금 더 풀어쓰면 `(signed) int a`는 `1111`을 -1로 해석하겠다는 뜻이다. 특별히 unsigned 인경우에는 `unsigned int a;`라고 적고 `1111`을 15로 해석하겠다는 뜻이다.

- long

    long 자료형의 경우 컴파일러에 따라 32bit나 64bit로 해석된다. C언어 버전인 C99에서 `long long int`라는 자료형이 추가되었다. 이 자료형은 64bit이다. `printf()`를 사용해서 출력하는 경우 `%lld`를 사용한다. 

### 실수형

> 10진수를 2진수로 변환하는 방법
>
> 2.25를 2진수로 변환하는 방법은 다음과 같다.
> 1. 정수는 몫이 1이 될 때까지 2로 나누고 몫부터 나머지를 아래부터 순서대로 적는다. 예를들어 2를 2진수로 변환해보자. `2 / 2`의 몫은 1이고 나머지는 0이다. 몫과 나머지를 순서대로 나열하면 10이다. 
> 2. 소수는 소수부분이 없어질 때 2를 곱하고 정수부분을 위에서 아래로 적는다. 0.25를 2진수로 변환해본다. `0.25 * 2 = 0.5`, `0.5 * 2 = 1.0`이다. 따라서 0.01이다.
> 3. 정수부분과 소수부분을 합친다. `10 + 0.01 = 10.01` 2.25를 2진수로 변환한 최종 결과는 10.01이다.

> 실수 상수 표현법
>
> `0.0000314`는 지수 표현법으로 나타내면 $3.14 * 10^{-5}$이다. (지수의 부호는 소수점이 오른쪽으로 이동하면 -, 왼쪽으로 이동하면 +이다.)이걸 C언어에서는 `3.14e-5`로 표기한다. 지수 표현법은 다양한 방법으로 할 수 있는데 위에서 본 것처럼 소수점 앞 한 자리가 0이 아닌 값을 사용하는 방법을 **정규화 표현법**이라고도 한다. (`3.14e-5`=정규화, `31.4e-4`!=정규화)

#### 실수형의 오차

실수형의 특징은 **오차**를 가지고 있다는 점이다. 그 원인은 크게 보면 **한정된 메모리 공간** 때문이다. 
사람은 십진수를 사용하기 때문에 0.1이 너무 쉽게 느껴진다. 하지만 주의해야 할 점은 컴퓨터는 이진법을 사용한다. 십진수 0.1을 이진법으로 표현하면 **무한소수**가 된다. 컴퓨터는 무한소수를 한정된 메모리에 저장해야 하기 때문에 일정길이 밑으로 값을 버린 **근사치**를 저장한다. 따라서 이렇게 저장한 값을 다시 십진수로 변환하는 경우 당연히 값이 달라지게 된다. 그렇기 때문에 실수형을 다룰 때는 **정밀도**를 잘 생각해야 한다.

#### 실수를 표현하는 방법 - 고정소수점 방식과 부동소수점 방식

정수형처럼 32bit를 사용해서 맨 앞 한자리는 부호를 표현하고 앞 15자리는 **정수**를 표현, 뒤 16자리는 **소수**를 표현할 수 있다. 이를 **고정 소수점 방식**이라고 한다. 이 경우 단점이 있다. 

정수와 소수의 표현 범위가 정해져 있기 때문에 큰 정수를 표시할 수 없거나 소수를 표현할 때 정밀하지 못하다. 정수가 클 때는 소수를 조금만 표현하고 정수가 작을 때는 소수를 정밀하게 표현할 수 있으면 공간적인 효율이 좋을 것이다. 이런 단점을 보완하기 위해서 **부동 소수점 방식**을 사용한다. 
    
> 부동 소수점 변환 방법
>
> 2진수를 10.01을 4바이트 부동소수점으로 변환하는 방법을 알아본다.
> 
> 1. 부호비트 : 부동소수점 방식의 가장 처음 비트는 **부호**를 나타낸다. 10.01은 양수이기 때문에 0이다.
> 
> 2. 지수부 : 10.01을 **정규화 표현식**으로 변환한다. 1.001로 소수점 앞에 한 자리가 0이 아닌 값이 되도록 소수점을 앞이나 뒤로 보내야 한다. (예 100.1 -> 1.001) 소수점이 한 자리 앞으로 이동했기 때문에 1.001 x $2^1$ 라고 표현할 수 있다. 이제 4바이트 bias 값인 127에 지수인 1을 더한 수(128)를 2진수로 변환해서 지수부를 구한다. `10000000`
>
> 3. 가수부 : 가수부는 1.001의 소수점 아래이다. `001`
>
> 4. 합체 : 부호비트 = `0`, 지수부 = `10000000`, 가수부 = `001`를 합치면 부동 소수점이 완성된다. 
>
> 5. 결과 : `0_1000000_00010000_00000000_00000000` (4바이트 이기 때문에 총 32bit로 공백은 0으로 채워준다.)

#### 실수형 종류

실수형에서 3가지 자료형이 있다.

- float : 32bit (소수점 이하 6자리) bias 64 or 127
- double : 64bit (소수점 이하 15자리) bias 1023
- long double : 79bit

한 가지 주의해야 할 점은 float과 double의 차이는 메모리 크기이다. double 역시 근사치로 값을 저장하기 때문에 **정밀도**를 염두해야 한다.

## 코드 파일로 분리하기 - 헤더 파일

코드를 작성하다 보면 하나의 파일에 너무 많은 코드가 존재해서 가독성이 떨어지고 유지보수가 어려워 질 수 있다. 이럴 때는 코드를 여러 파일로 분리할 수 있다. 
하나의 파일을 3개의 파일로 분리할 수 있다. 
1. main 함수가 들어있는 **실행 파일**
2. 함수가 선언되어 있는 **헤더 파일**(`.h`)
3. 헤더 파일에 선언된 함수가 구현되어 있는 **구현 파일**(`.c`)

예시로 아래와 같은 파일을 3개의 파일로 분리해본다.

```C
int sum(int a, int b)
{
    return a + b;
}

int main(void)
{
    sum(1, 1);
}
```

먼저 함수를 선언할 헤더 파일(`sum.h`)을 생성하고 함수의 선언부를 적는다.

```C
int sum(int a, int b);
```

선언할 함수의 구현을 적는 구현 파일(`sum.c`)을 생성하고 함수를 구현한다.

```C
int sum(int a, int b)
{
    return a + b;
}
```

이제 main 함수가 있는 실행 파일에서 sum()을 지우고 헤더 파일을 추가한다. 

```C
#include "sum.h"  // 헤더 파일 추가

int main(void)
{
    sum(1, 1);
}
```