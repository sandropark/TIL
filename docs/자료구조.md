# 자료구조

- 참고자료
    - [자료구조 - Data Structures with Python (신찬수)](https://youtube.com/playlist?list=PLsMufJgu5933ZkBCHS7bQTx0bncjwi4PK)
    - [C로 배우는 자료구조 (널널한 개발자)](https://youtube.com/playlist?list=PLXvgR_grOs1AiEXL3Xfy6yEZ7k2TL4rxy)

자료구조는 **데이터 베이스**를 이루는 기술이다. 많은 데이터를 관리하기 쉽게 구조화하다보니 자료구조가 탄생하게 되었다.

## 목차

### [선형 자료구조](#선형-자료구조)

- [Array 배열](#array-배열)
- [List 리스트](#list-리스트)
- [Linked List 연결리스트](#linked-list-연결리스트)
- [Stack 스택](#stack-스택)
- [Queue 큐](#queue-큐)
- [Hash Table 해시테이블](#hash-table-해시-테이블)

### [비선형 자료구조](#비선형-자료구조)

- [Tree 트리](#tree-트리)
- [Heap 힙](#heap-힙)
- [Binary Tree 이진트리](#binary-tree-이진트리)
- [Graph 그래프](#graph-그래프)

## ADT - 추상자료형

**자료**와 **관리체계**를 분리하는 것이 핵심이다. 연결 리스트로 예를들면 지금까지는 node 구조체 안에 `데이터1, 데이터2, 데이터..., 이전 노드 포인터, 다음 노드 포인터`이런 식으로 담았다면
ADT를 사용하면 데이터는 다른 구조체로 분리한다. `데이터 구조체 포인터, 이전 노드 포인터, 다음 노드 포인터` 이런 식으로 말이다. 이렇게 분리하면 하나의 관리체계를 이용해서 다양한 자료를 다룰 수 있다.

# 선형 자료구조

## Array 배열

배열의 가장 큰 특징은 **인덱스**를 사용해서 `O(1)`(상수시간)으로 데이터에 접근이 가능하다.

```c
int arr[5] = {1, 3, 4, 2, 5};
```

5개의 정수를 담는 배열이 있다. 정수 한 개는 4바이트로 메모리에 4바이트의 공간이 5개 연달아서 할당된다. 실제로 연달아서 자리하기 때문에 가장 처음 데이터의 메모리 주소를 알면 각 데이터의 메모리 주소는 바로
계산할 수 있다.

예를 들어 가장 처음 데이터의 주소가 `0x00`이라면 두번째 데이터의 주소는 정수형의 크기인 4바이트 만큼 건너뛰면 된다. `0x00 + 4bytes(int) * 1 = 0x04`다. 가장 처음 데이터의 주소는
변수 `arr`에 저장되어 있다. arr[2]는 내부적으로 `0x00(처음 데이터 주소) + 4bytes(int) * 2 = 0x08` 이렇게 주소를 계산해서 해당 주소에 들어있는 데이터를 반환해준다.
인덱스는 +,* 연산만 하면 되기 때문에 상수 시간으로 요소에 접근할 수 있다.

## List 리스트

자바나 파이썬에서는 **리스트**라는 자료형을 제공한다. 리스트는 배열에 다양한 기능이 추가된 확장된 자료구조라고 할 수 있다. 리스트는 데이터의 용량을 관리하는 로직을 갖고있다. 리스트를 사용하는 사람이 용량을
신경쓰지 않아도 된다. 이런 특징 때문에 리스트를 **Dynamic Array**라고도 한다.

## Linked List 연결리스트

## Stack 스택

LIFO (last in first out) 후입선출, 즉 마지막에 추가된 요소가 가장 먼저 나가는 자료구조이다. 뷔페에 쌓여있는 접시를 생각하면 편하다.

- 기능
    - push : 요소 추가. `O(1)`
    - pop : 가장 마지막에 추가된 요소 삭제. `O(1)`
    - top : 가장 마지막에 추가된 요소 조회. `O(1)`
    - len : 스택의 요소 수 조회 `O(1)`

### postfix

`2+3*5` 같은 식을 **infix 수식**이라고 한다. postfix 수식을 사용하면 스택을 사용해서 계산하기 쉬워진다.

- infix to postfix
    1. 괄호치기 : `(2+(3*5))`
    2. 연산자를 자신의 오른쪽 괄호로 이동 : `(2(35)*)+`
    3. 괄호제거 : `235*+`

`3*(2+5)*4` -> `((3*(2+5))*4)` -> `((3(25)+)*4)*` -> `325+*4*`

prefix 방식도 있다. postfix와 반대로 생각하면 된다.

## Queue 큐

FIFO (first in first out) 선입선출, 즉 처음 추가한 요소가 가장 먼저 나가는 자료구조다. 대기줄을 생각하면 된다.

## Hash Table 해시 테이블

해시 테이블은 삽입, 삭제, 조회를 상수시간에 할 수 있는 자료구조다. key와 value로 이루어진 데이터를 다룬다.

데이터의 키를 `Hash function`에 넣어서 데이터가 담길 배열의 인덱스를 생성한다. 예를 들어 `나이:10, 이름:둘리` 라는 데이터를 해시 테이블에 저장하기 위해서는 먼저 key인 10을 hash
function에 넣어서 배열의 인덱스를 구한다. 배열의 크기를 10으로 가정해서 해시 함수를 아주 간단하게 `key % 10(배열의 크기)`로 정할 수 있다. 둘리의 key를 해시 함수에 넣으면 인덱스 0을 구할
수 있다. (`10 % 10 = 0`) 따라서 둘리는 배열의 0번 인덱스에 저장된다.

만약 `나이:20, 이름:마이콜` 을 해시 테이블에 저장하려고 하면 `collision`이 발생한다. 마이콜의 인덱스는 0인데 이미 인덱스 0에 둘리 데이터가 들어있기 때문이다. 이렇게 충돌이 발생하는 경우 해결하는
방법을 `collision resolution method` 라고 한다.

해시 테이블에서는 `hash function`과 `collision resolution method`이 성능에 큰 영향을 끼친다.

# 비선형 자료구조

## Tree 트리

2차원 구조를 갖는 **비선형 자료구조**다. 각 노드는 하나 이상의 하위 노드를 갖는다.

- 루트
    - 최상위 노드
- 부모와 자식
    - 상대적으로 다른 노드의 위에 있으면 **부모**, 아래에 있으면 **자식**이라고 한다.
- 리프
    - 자식이 없는 노드
- Link / Edge
    - 노드와 노드를 잇는 선
- 경로
    - A노드에서 C노드까지 가는 길. A -> B -> C 경우 경로의 길이는 2다.

## 이진 트리를 코드 상에서 표현하는 방법

<img width="250" src="https://user-images.githubusercontent.com/89520805/231468727-6e0f37fd-7158-40c0-be7b-5d6da3dd1c91.png"/>

이진 트리를 코드로 표현하는 방법을 알아본다.

### 표현법 1 - 리스트

```python
A = [a, b, c, None, d, e, f]
```

위에서 아래로, 왼쪽에서 오른쪽으로 리스트를 채워나간다. 노드가 비어있는 경우 `None`을 넣는다.

- 자식 노드를 구하는 법

A[0]의 왼쪽 자식 노드는 A[1]이고 오른쪽 자식 노드는 A[2]다. A[1]의 왼쪽 자식 노드는 A[3]이고 오른쪽 자식 노드는 A[4]다.
이런 식으로 표현법 1은 자식 노드를 구하기 쉽다.

A[i]의 자식노드는 `A[i * 2 + 1], A[i * 2 + 2]`이다.

반대로 부모 노드를 구할 때는 `A[(i - 1) // 2]`를 하면 된다.

이렇게 자식, 부모 노드를 구할 때는 `O(1)`의 연산으로 가능하다.

### 표현법 2 - 리스트 (재귀적)

```python
A = [a, [b, [], [d, [], []]], [c[e, [], []], [f, [], []]]]
```

부모 노드와 오른쪽 자식 노드, 왼쪽 자식 노드를 재귀적으로 표현한다. 자식이 없는 경우 빈 리스트를 사용한다.

### 표현법 3 - Node 클래스

```Java
class Node {
    private Node parent;
    private String key;
    private Node left;
    private Node right;
}
```

각 노드를 클래스로 관계를 표현할 수 있다.

## Heap 힙

조건을 만족하는 이진트리를 힙이라고 한다. **최대값**이나 **최소값**을 빠르게 찾기 위한 자료구조다.

- 조건
    1. 모양 : 리프 노드가 왼쪽부터 채워지는 **완전 이진 트리**
    2. Heap 성질 : 부모 노드는 자식 노드와 같거나 커야 한다. 따라서 힙의 루트 노드는 모든 노드 중에 가장 크다.

- 제공 연산
    - [make-heap](#make-heap-연산) : input을 힙 성질이 만족하도록 자리바꿈하는 연산이다.
    - [insert](#insert-연산) : O(log n)
    - [find-max](#find-max-연산) : O(1)
    - [delete-max](#delete-max-연산) : O(log n)

### Make Heap 연산

<img width="300" alt="image" src="https://user-images.githubusercontent.com/89520805/231472383-61b7674d-7a05-483f-8b53-f7ff5e15d260.png">

<img width="300" alt="image" src="https://user-images.githubusercontent.com/89520805/231481789-b20ecd31-8efe-41a6-a5fe-db1c362b998a.png">

리스트로 표현된 완전 이진 트리가 있다. 힙 성질을 만족시키는 `Make Heap` 연산을 통해서 힙으로 만들어 본다.
리스트의 가장 마지막 원소부터 첫 번째 원소까지 반대로 순회하면서 각 노드가 힙 성질을 만족하는지 확인한다.
자식과 비교해서 자신보다 큰 자식 중 더 큰 자식과 자리를 바꾼다. 모든 노드를 순회해서 힙 성질을 만족하게 만드는 연산이다. 이 연산을 `heapify_down`이라고 한다.

가장 마지막 원소인 `11`부터 확인한다. 리프 노드라면 힙 성질을 만족하는 것으로 간주해서 넘어가고 이전 노드를 확인한다. `12` 역시 리프 노드라 넘어간다. `3, 15, 10` 모두 건너뛰고 `1`
이다. `1`은 자식 노드가 있기 때문에 자식 노드를 확인한다. `12`와 `11`이다. 자식 모두 `1` 보다 크다. 자식 중 더 큰 `12`와 `1`을
바꾼다. `A = [2, 8, 6, 12, 10, 15, 3, 1, 11]`이 된다. 자리를 바꾸고 `1`을 다시 확인한다. 리프 노드이기 때문에 넘어간다.

이런 식으로 루트 노드까지 순회하면서 힙 성질을 만족하게 만드는 것이다. Make Heap은 `O(n)`이다.

### Insert 연산

힙에 새로운 원소를 추가할 때도 그냥 추가하면 안되고 힙 성질을 만족해야 한다.

<img width="300" alt="image" src="https://user-images.githubusercontent.com/89520805/231786171-c5e98e46-4bf6-4383-a065-f250536bd1ca.png">

그림과 같은 힙에 `14`를 추가한다.

<img width="300" alt="image" src="https://user-images.githubusercontent.com/89520805/231786494-477f1f08-c2b1-42f4-8828-5d3d38094dc1.png">

추가한 `14`는 부모인 `10`보다 크기 때문에 힙 성질을 만족하지 않는다. 따라서 위치를 조정해야 한다. `14`와 부모인 `10`을 비교해서 부모가 더 작다면 둘의 자리를 바꾼다.

<img width="300" alt="image" src="https://user-images.githubusercontent.com/89520805/231787211-cbc237a7-d6f7-4868-8ebd-47a2e9bf9687.png">

자리를 바꾼 다음 다시 부모와 비교해서 자리를 바꾼다.

<img width="300" alt="image" src="https://user-images.githubusercontent.com/89520805/231788868-e7c8889c-9bb4-4f7d-b7aa-50d43f6b741a.png">

새로 추가한 노드가 부모보다 작거나 루트 노드가 될 때까지 반복한다. 이렇게 하면 새로운 요소를 추가해도 힙 성질을 유지할 수 있다. 최악의 경우 새로 추가한 노드가 루트가 되는 경우기 때문에 `O(log n)`
이다.

### Find max 연산

힙의 요소 중 루트 노드가 가장 큰 원소기 때문에 `return H[0]`을 하면 된다. `O(1)`이다.

### Delete max 연산

1. 루트 노드를 삭제
2. 가장 마지막 노드를 루트 노드로 만든다.
3. `Heapify down`을 이용해서 힙 성질을 만족한다.

   자식 노드와 비교해서 더 큰 자식 노드와 자리를 바꾸면서 자리를 찾아간다.

Heapify down을 하기 때문에 `O(log n)`이다.

---

#### 힙 정리

힙을 사용해서 **Heap sort**를 할 수 있다.

리스트의 원소를 `Make Heap`을 사용해서 힙으로 만들고 가장 마지막 원소와 루트(가장 큰 원소)를 자리 바꿈한다. 리스트에서 가장 큰 값이 리스트의 맨 마지막 원소가 된다. 새로운
루트는 `heapify down`으로 제자리를 찾는다. 이런 식으로 리스트의 맨 마지막부터 맨 앞까지 순회하면서 정렬을 한다. `O(n log n)`이다.

## Binary Tree 이진트리

자식 노드 최대 2개인 트리를 뜻한다. 트리 중 가장 많이 다뤄진다.

### Binary Search Tree 이진 탐색 트리

이진 트리가 **이진 탐색 트리**가 되기 위해서는 조건이 있다. 현재 노드를 기준으로 왼쪽 하위 모든 노드는 현재 노드 보다 작아야하고 반대로 오른쪽은 하위 모든 노드는 커야한다.

### Complete Binary Tree 완전 이진 트리

리프 노드가 왼쪽부터 채워지는 이진 트리를 뜻 한다.

### Full Binary Tree

자식을 갖지 않거나 가지려면 2개를 모두 가지는 이진 트리를 뜻한다.

### Perfect Binary Tree

말 그대로 완벽한 상태다. 루트를 기준으로 정확히 **대칭**인 이진 트리를 뜻한다.

## 이진 트리 순회 방법

이진 트리를 순회하는 방법은 3가지가 있다.

- Inorder   : Left, Root, Right
- Preorder  : Root, Left, Right
- Postorder : Left, Right, Root

노드의 데이터를 출력하는 상황을 예시로 살펴본다. 모두 출력값은 1,2,3으로 동일하다.

### Inorder

```
   2
 /   \
1     3
```

### Preorder

```
   1
 /   \
2     3
```

### Inorder

```
   3
 /   \
1     2
```

## Graph 그래프

### 용어

- Node / Vertex
- Edge / Link : 방향이 있는 엣지의 경우 해당 방향으로만 이동할 수 있다. 방향이 없다면 양방향 엣지다.
    - 가중치 : 엣지에는 가중치가 존재할 수 있다.
- Degree (분지수) : 인접한 Node의 수 == Edge의 수. Node와 Node는 Edge로 이어져있기 때문이다.
- Path : 어떤 노드에서 출발해서 어떤 노드에 도달할 수 있는 경로.
  여러 가지 경우의 수가 있지만 하나의 경로에는 중복된 노드가 있으면 안된다.
    - Cycle : 하나의 노드에서 출발해서 다시 해당 노드로 돌아오는 Path. Cycle이 없는 그래프는 **트리**다.
      Cycle이 존재하는 그래프에서는 두 노드를 연결하는 경로는 2개 이상있다.

### 표현법

- 인접 행렬 (adjacency matrix)

  <img width="200" alt="image" src="https://user-images.githubusercontent.com/89520805/236397444-dedbc04d-1a82-4319-b92a-031aebf8ad83.png">

- 인접 리스트 (adjacency list) : 연결리스트다.

  <img width="300" alt="image" src="https://user-images.githubusercontent.com/89520805/236397540-f9813072-6817-4d2b-bdb8-57b6e59929f5.png">

### 인접 행렬과 인접 리스트 비교

그래프(`G`)는 Node(또는 Vertex)의 집합과 Edge의 집합으로 이루어져 있다. `G = (V, E)`
그리고 노드의 집합은 `n`, 엣지의 집합은 `m`으로 표현한다. `|V| = n, |E| = m`

아래와 같은 그래프를 인접 행렬과 인접 리스트로 나타내서 비교해본다.

<img width="200" alt="image" src="https://user-images.githubusercontent.com/89520805/236399664-6133b9f1-049d-4607-b948-8fbe37b90664.png">

|                            | 인접 행렬                                        | 인접 리스트                                                                   |
|----------------------------|----------------------------------------------|--------------------------------------------------------------------------|
| memory                     | O(n^2)                                       | **O(n + m)**                                                             |
| search : (u, v) in E?      | **O(1)**<br/>`G[u][v] == 1`로 상수 시간에 찾을 수 있다. | O(n)<br/>u에 연결된 리스트를 모두 순회해야 한다. <br/>최악의 경우 u가 모든 노드와 인접하다면 `n-1`번 순회해야 한다. |
| u에 인접한 <br/>모든 v에 대해 작업 수행 | O(n) <br/> G[u]의 모든 노드를 순회해야 한다.             | **O(n)** <br/>최악의 경우 인접한 모든 노드를 순회해야 하지만 인접하지 않았다면 데이터가 없기 때문에 행렬보다는 효율적이다. |
| insert                     | **O(1)** <br/>`G[u][v] = 1`로 설정하면 된다.        | **O(1)** <br/>`G[u].pushFront(v)`로 상수 시간에 가능.                            |
| delete                     | **O(1)** <br/>`G[u][v] = 0`로 설정하면 된다.        | O(n) <br/>`G[u].search(v)`하고 삭제해야 한다.                                    |
    
노드에 비해 엣지가 확연히 적은 그래프(sparse)를 인접 행렬로 표현하면 메모리 비효율이 심하다. 

### 그래프 순회

#### DFS (Depth First Search)

DFS는 인접한 노드를 중 일정한 조건(값이 작은 노드 먼저 같은)으로 리프 노드에 도달할 때까지 타고 들어간다. 
만약 리프 노드에 도착했다면 **이전 노드로 돌아가서** 다음 조건에 해당하는 노드를 방문하면서 다시 리프 노드까지 타고 들어간다. 이런 식으로 그래프를 순회하는 방법이다.

#### BFS (B First Search)

BFS는 현재 노드에 인접한 노드를 모두 방문한다. `B-A-C` A에서 시작했다면 B갔다가 돌아와서 C에 방문한다. 
그리고나서 B로 가서 B에 인접한 노드를 모두 방문한다.















